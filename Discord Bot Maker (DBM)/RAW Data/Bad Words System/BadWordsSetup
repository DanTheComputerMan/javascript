{
  "name": "BadWordsSetup",
  "permissions": "NONE",
  "restriction": "1",
  "_id": "ghoTP",
  "actions": [
    {
      "comment": "DON'T touch this, use the command itself to config the system.",
      "color": "#ff8040",
      "name": "Comment"
    },
    {
      "behavior": "0",
      "interpretation": "1",
      "code": "// Javascript code here. Do NOT edit this or you WILL break it.\nconst WrexMODS = this.getWrexMods();\nconst db = WrexMODS.require('quick.db');\n\nvar wordlist = db.get(`servers.${server.id}.badwordsystem.badwordlist`) || [{\"word\":\"anal\",\"action\":\"delete\"},{\"word\":\"anus\",\"action\":\"delete\"},{\"word\":\"arse\",\"action\":\"delete\"},{\"word\":\"ass\",\"action\":\"delete\"},{\"word\":\"ballsack\",\"action\":\"delete\"},{\"word\":\"balls\",\"action\":\"delete\"},{\"word\":\"bastard\",\"action\":\"delete\"},{\"word\":\"bitch\",\"action\":\"delete\"},{\"word\":\"blowjob\",\"action\":\"delete\"},{\"word\":\"blow job\",\"action\":\"delete\"},{\"word\":\"boner\",\"action\":\"delete\"},{\"word\":\"boob\",\"action\":\"delete\"},{\"word\":\"clitoris\",\"action\":\"delete\"},{\"word\":\"cock\",\"action\":\"delete\"},{\"word\":\"coon\",\"action\":\"delete\"},{\"word\":\"cunt\",\"action\":\"delete\"},{\"word\":\"damn\",\"action\":\"delete\"},{\"word\":\"dick\",\"action\":\"delete\"},{\"word\":\"dildo\",\"action\":\"delete\"},{\"word\":\"dyke\",\"action\":\"delete\"},{\"word\":\"fag\",\"action\":\"delete\"},{\"word\":\"fellate\",\"action\":\"delete\"},{\"word\":\"fellatio\",\"action\":\"delete\"},{\"word\":\"fuck\",\"action\":\"delete\"},{\"word\":\"goddamn\",\"action\":\"delete\"},{\"word\":\"god damn\",\"action\":\"delete\"},{\"word\":\"hell\",\"action\":\"delete\"},{\"word\":\"homo\",\"action\":\"delete\"},{\"word\":\"jizz\",\"action\":\"delete\"},{\"word\":\"labia\",\"action\":\"delete\"},{\"word\":\"nigga\",\"action\":\"delete\"},{\"word\":\"nigger\",\"action\":\"delete\"},{\"word\":\"penis\",\"action\":\"delete\"},{\"word\":\"pube\",\"action\":\"delete\"},{\"word\":\"pussy\",\"action\":\"delete\"},{\"word\":\"queer\",\"action\":\"delete\"},{\"word\":\"scrotum\",\"action\":\"delete\"},{\"word\":\"sex\",\"action\":\"delete\"},{\"word\":\"shit\",\"action\":\"delete\"},{\"word\":\"slut\",\"action\":\"delete\"},{\"word\":\"smegma\",\"action\":\"delete\"},{\"word\":\"tit\",\"action\":\"delete\"},{\"word\":\"twat\",\"action\":\"delete\"},{\"word\":\"vagina\",\"action\":\"delete\"},{\"word\":\"wank\",\"action\":\"delete\"},{\"word\":\"whore\",\"action\":\"delete\"}];\nconst onoff = db.get(`servers.${server.id}.badwordsystem.status`) || false;\nconst logchannel = bot.channels.get(String(db.get(`servers.${server.id}.badwordsystem.logchannelID`))) || false;\n\nfunction trim(str) { // Trims leading and trailing spaces from a string.\n\treturn str.replace(/^\\s+|\\s+$/gm,'');\n}\n\nfunction ConvArrToObj(array) { // Converts default bad word list to an object format.\n\tlet a = array.map(bword => (typeof(bword) != 'object') ? Object.assign({ word: String(bword), action: 'delete' }) : bword); // sets entries that are not in array format to themselves (i.e. ones that have already been converted to object format.)\n\tfor (var i in a) { // Converts {} empty objects to < empty item > so that boolean check below can work.\n\t\tif (!a[i] || typeof a[i] !== \"object\") {\n\t\t\tcontinue // If null or not an object, skip to the next iteration\n\t\t}\n\t\t\n\t\t// The property is an object\n\t\tif (Object.keys(a[i]).length === 0) {\n\t\t\tdelete a[i]; // The object had no properties, so delete that property\n\t\t}\n\t}\n\treturn a.filter(Boolean); // Removes {} empty objects.\n}\n\n// For every function part.     Bigger array, smaller array.    It's a function, so call it like checker(bigger_arr, smaller_arr);\nvar checker = (arr, target) => target.every(p => arr.includes(p));\n\nconst configtypes = ['usertype', 'wordtype'];\n\nconst prefix = (server && server.tag) || Files.data.settings.tag;\nconst args = msg.content.slice(prefix.length).trim().split(/ +/g); \nconst command = args[0]; args.shift();\n\nconst nickname = msg.member.displayName;\n\nconst bossperms = ['ADMINISTRATOR', 'MANAGE_GUILD'];\nconst regperms = ['BAN_MEMBERS', 'KICK_MEMBERS', 'MANAGE_MESSAGES'];\nconst self = server.me; var permArr = [];\n\nvar selfperms = self.permissions.serialize();\nlet selperm = Object.entries(selfperms);\nvar memberperms = member.permissions.serialize();\nlet memperm = Object.entries(memberperms);\n\n// Gets permissions that are true.\nfor (i = 0; i < Object.keys(selfperms).length; i++) {\n  if (selperm[i][1] === true) {\n    permArr.push(selperm[i][0]);\n  }\n}\nvar selftierone = permArr.some(p=> bossperms.indexOf(p) >= 0);\nvar selftiertwo = (selfperms, regperms) => regperms.every(p => selfperms.includes(p));\n\npermArr = [];\nfor (i = 0; i < Object.keys(memberperms).length; i++) {\n  if (memperm[i][1] === true) {\n    permArr.push(memperm[i][0]);\n  }\n}\nvar membertierone = permArr.some(p=> bossperms.indexOf(p) >= 0);\n\n\n\n\nconst tutorial = `https://github.com/DanTheComputerMan/javascript/tree/master/Discord%20Bot%20Maker%20(DBM)/RAW%20Data/Bad%20Words%20System`\n\nif (!args[0]) {\n\tmsg.channel.send(`Command Usage:\n**${prefix}${command} guide**\n**${prefix}${command} check**\n**${prefix}${command} enable**\n**${prefix}${command} disable**\n**${prefix}${command} config**\n**${prefix}${command} addwords wordone | word two | \"word three\" as a quote**\n**${prefix}${command} delwords wordone | word two | \"word three\" as a quote**\n**${prefix}${command} logchannel [mentioned channel]**\nExample:\n**${prefix}${command} logchannel #bot-output**`);\n} else if (!(['guide', 'check', 'enable', 'disable', 'config', 'addwords', 'delwords', 'logchannel'].includes(args[0]))) {\n\tmsg.reply(`You must provide a valid option. The options are as follows:\n**${prefix}${command} guide**\n**${prefix}${command} check**\n**${prefix}${command} enable**\n**${prefix}${command} disable**\n**${prefix}${command} config**\n**${prefix}${command} addwords**\n**${prefix}${command} delwords**\n**${prefix}${command} logchannel [mentioned channel]**`);\n} else {\n\tvar mode = args[0];\n\tif (membertierone && (selftierone || selftiertwo)) {\n\t\t// both command author and bot have perms, and user can set this up.\n\t\tif (mode == 'guide') {\n\t\t\tmsg.reply(`The full guide can be found here: ${tutorial}`)\n\t\t} else if (mode == 'check') {\n\t\t\tmsg.reply(`The system is currently ${(onoff == true) ? \"enabled\" : \"disabled\"}.`);\n\t\t} else if (mode == 'enable') { // enabling code\n\t\t\tif (onoff == true) {\n\t\t\t\tmsg.reply(\"System is already enabled!\");\n\t\t\t} else {\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.status`, true)\n\t\t\t\tmsg.reply(`Bad Word System has been enabled. To disable this later, just run **${prefix}${command} disable**. ${(logchannel) ? \"\" : \"Remember to set the log channel!\"}`);\n\t\t\t}\n\t\t} else if (mode == 'disable') { // disabling code\n\t\t\tif (onoff == false) {\n\t\t\t\tmsg.reply(\"System is already disabled!\");\n\t\t\t} else {\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.status`, false)\n\t\t\t\tmsg.reply(`Bad Word System has been disabled. To enable this later, just run **${prefix}${command} enable**.`);\n\t\t\t}\n\t\t} else if (mode == 'config') { // multiple configuration options including @mention or usertag option.\t\t\n\t\t\tlet usersubtype = ['check', '@mention', 'usertag']; let wordsubtype = ['check', 'matchany', 'matchanycasingmatters', 'matchword', 'matchwordcasingmatters'];\t\t\n\t\t\tlet allsubtypes = usersubtype.concat(wordsubtype);\t\t\n\t\t\tif (!args[1] || !configtypes.includes(args[1])) { \t\t\n\t\t\t\tmsg.reply(`you must select a configuration option. The options are as follows: **\\`usertype\\`, \\`wordtype\\`**`);\t\t\n\t\t\t} else if (!args[2] || !allsubtypes.includes(args[2])) {\t\t\n\t\t\t\t// Yes, b/c of the escaped ` symbols, it looks wierd.\t\t\n\t\t\t\tmsg.reply(`you must select a configuration sub-type. ${(args[1]=='usertype') ? \"The options are as follows: **\\`\"+usersubtype.join('\\`**, **\\`') : (args[1]=='wordtype') ? \"The options are as follows: **\\`\"+wordsubtype.join('\\`**, **\\`') : \"You didn't select a valid configuration option.\"}\\`**`)\t\t\n\t\t\t\t// `\t\t\n\t\t\t} else {\t\t\n\t\t\t\tswitch (args[1]) {\t\t\n\t\t\t\t\tcase \"usertype\":\t\t\n\t\t\t\t\t\tif (args[2].match(/check/i)) {\t\t\n\t\t\t\t\t\t\tmsg.reply(`the system is currently set as **\\`${db.get(`servers.${server.id}.badwordsystem.usertype`) || '@mention'}\\`**.`);\t\t\n\t\t\t\t\t\t} else {\t\t\n\t\t\t\t\t\t\t(args[2].match(/@?(user|u)?mention/)) ? db.set(`servers.${server.id}.badwordsystem.usertype`, '@mention') : (args[2].match(/(user|u)?tag/)) ? db.set(`servers.${server.id}.badwordsystem.usertype`, 'usertag') : null\t\t\n\t\t\t\t\t\t\tmsg.reply(`${(args[2] == 'check') ? `the usertype is currently set as **\\`${usertype}\\`**.` : (args[2].match(/@?(user|u)?mention/)) ? \"successfully set the usertype to @mention instead of tag (Rando#1234).\" : (args[2].match(/(user|u)tag/)) ? \"successfully set the usertype to user tag (Rando#1234) instead of @mention. Enjoy not having the pings.\" : \"you need to choose either **`@mention`** or **`usertag`** option.\" }`)\t\t\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\tcase \"wordtype\":\t\t\n\t\t\t\t\t\tif (args[2].match(/check/i)) {\t\t\n\t\t\t\t\t\t\tmsg.reply(`the system is currently set as **\\`${db.get(`servers.${server.id}.badwordsystem.wordtype`) || 'matchany'}\\`**.`)\t\t\n\t\t\t\t\t\t} else if (args[2].match(/match(any|anycasingmatters|word|wordcasingmatters)/i)) {\t\t\n\t\t\t\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.wordtype`, String(args[2].match(/match(any|anycasingmatters|word|wordcasingmatters)/i)[0]).toLowerCase())\t\t\n\t\t\t\t\t\t} else {\t\t\n\t\t\t\t\t\t\targs.shift(); args.shift(); \t\t\n\t\t\t\t\t\t\tmsg.reply(`**${args.join(' ')}** wasn't a valid subtype. The valid subtypes are ${wordsubtype.join(', ')}.`);\t\t\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\tdefault:\t\t\n\t\t\t\t\t\tmsg.reply(`that wasn't a valid configuration option. The options are as follows: **\\`${allsubtypes.join(' ')}\\`**`);\t\t\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\t\t\n\t\t\t}\t\t\n\t\t} else if (mode == 'delwords') {\n\t\t\tvar oldwordarr = []; let user_typed_words_check = args; user_typed_words_check.shift(); c(wordlist);\n\t\t\tif (user_typed_words_check.length <= 0) {\n\t\t\t\tmsg.channel.send(`${nickname}, you didn't type any words to delete!`);\n\t\t\t} else {\n\t\t\t\targs.join(' ').trim().split(/\\|/g).forEach(function(element) { oldwordarr.push(trim(element)); });\n\t\t\t\tvar wordlisttwo = wordlist.filter(b=>b.word).map(b=>b.word.toLowerCase()); // Removes all regular ojects from array and leaves objects for what's left ({word: 'example', action: 'delete'}, {word: 'testing', action: 'ban'}, etc)\n\t\t\t\tvar wordlistthree = wordlist.filter(b=>!b.word).map(b=>b.word.toLowerCase()); // Removes all objects from array and leaves regular entries for what's left ('pussy', 'cunt', etc).\n\t\t\t\tvar wordlistfour = wordlisttwo.concat(wordlistthree); // All words stored in wordlist. Now I need to compare them, and not remove words that aren't already there. Once I have a list of all words to remove, I remove them from the wordlistfour variable. Then I need to run a findindex or whatever to find the word in the main badwordlist and add/push it back with the appropriate disciplinary action.\n\t\t\t\tfunction appendObjTo(thatArray, newObj) { // Adds objects { word: 'word', action: 'delete' } to an array.\n\t\t\t\t\treturn thatArray.concat(newObj);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < wordlistfour.length; i++) {\n\t\t\t\t\tif (oldwordarr.includes(wordlistfour[i])) {\n\t\t\t\t\t\twordlistfour.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Okay, now that all words the user wanted removed are removed, set the list back up where\n\t\t\t\t// each remaining word has its appropriate disciplinary action back.\n\t\t\t\toldwordarr = [];\n\t\t\t\tfor (var i = 0; i < wordlistfour.length; i++) {\n\t\t\t\t\toldwordarr = appendObjTo(oldwordarr, {word: wordlistfour[i], action: Object.entries(wordlist.find(bword => String(bword.word).toLowerCase() === wordlistfour[i]))[1][1]} ); // Adds the word back with the appropriate disciplinary action.\n\t\t\t\t}\n\t\t\t\twordlist = oldwordarr; // Now contains the updated bad word object array with removed words.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.badwordlist`, wordlist); // Saves word list with removed words back to the saved word list.\n\t\t\t\t\n\t\t\t\tmsg.channel.send(`Removed all applicable words from the bad word list for this server.`);\n\t\t\t}\n\t\t} else if (mode == 'addwords') {\n\t\t\tvar oldwordarr = []; let user_typed_words_check = args; user_typed_words_check.shift(); \n\t\t\tif (user_typed_words_check.length <= 0) { // user didn't type any words\n\t\t\t\tmsg.channel.send(`${nickname}, you didn't type any words to add!`);\n\t\t\t} else {\n\t\t\t\tvar newwordarr = []; var newwordarrtwo = []; c('args at start is: '+args)\n\t\t\t\targs.join(' ').trim().split(/\\|/g).forEach(function(element) { newwordarr.push(trim(element)); });\n\t\t\t\t\n\t\t\t\tvar wordlisttwo = wordlist.filter(b=>b.word).map(b=>b.word.toLowerCase()); // Removes all regular ojects from array and leaves objects for what's left ({word: 'example', action: 'delete'}, {word: 'testing', action: 'ban'}, etc)\n\t\t\t\tvar wordlistthree = wordlist.filter(b=>!b.word).map(b=>b.word.toLowerCase()); // Removes all objects from array and leaves regular entries for what's left ('pussy', 'cunt', etc).\n\t\t\t\tvar wordlistfour = wordlisttwo.concat(wordlistthree); // All words stored in wordlist. Now I need to compare them, and add words that aren't already there. Once I have a list of all words to add, I add them to the wordlistfour variable. Then I need to run a findindex or whatever to find the word in the main badwordlist and add/push it back with the appropriate disciplinary action.\n\t\t\t\tfunction appendObjTo(thatArray, newObj) { // Adds objects { word: 'word', action: 'delete' } to an array.\n\t\t\t\t\treturn thatArray.concat(newObj);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < newwordarr.length; i++) {\n\t\t\t\t\tif (!(wordlistfour.includes(newwordarr[i]))) {\n\t\t\t\t\t\t// wordlistfour.splice(i, 1);\n\t\t\t\t\t\tnewwordarrtwo = appendObjTo(newwordarrtwo, {word: newwordarr[i], action: 'delete'} ); // Adds the word with the delete disciplinary action. Will allow customizability later.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Now newwordarrtwo contains all new words they want, and in object format. I now need to convert wordlistfour variable to object format with the appropriate disciplinary action. After that, concatenate the two and save it back to quick.db\n\t\t\t\t\n\t\t\t\t// Okay, now that all words the user wanted removed are removed, set the list back up where\n\t\t\t\t// each remaining word has its appropriate disciplinary action back.\n\t\t\t\tnewwordarr = [];\n\t\t\t\tfor (var i = 0; i < wordlistfour.length; i++) {\n\t\t\t\t\toldwordarr = appendObjTo(oldwordarr, {word: wordlistfour[i], action: Object.entries(wordlist.find(bword => String(bword.word).toLowerCase() === wordlistfour[i]))[1][1]} ); // Adds the word back with the appropriate disciplinary action.\n\t\t\t\t}\n\t\t\t\twordlist = oldwordarr; // Now contains original badword list.\n\t\t\t\twordlist = wordlist.concat(newwordarrtwo); // Now contains the updated bad word object array with the added words.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.badwordlist`, wordlist)\n\t\t\t\t\n\t\t\t\tmsg.channel.send(`Added all applicable words to the bad word list for this server.`);\n\t\t\t}\n\t\t} else if ((mode == 'logchannel') && !args[1]) {\n\t\t\tmsg.reply(`${(logchannel) ? \"Log channel is currently set as: \"+logchannel : \"No log channel set, please mention a log channel to set it to.\"}`);\n\t\t} else if ((mode == 'logchannel') && (msg.mentions && msg.mentions.channels && msg.mentions.channels.first())) {\n\t\t\tdb.set(`servers.${server.id}.badwordsystem.logchannelID`, msg.mentions.channels.first().id);\n\t\t\tmsg.reply(`Log channel successfully set to ${msg.mentions.channels.first()}.`);\n\t\t} else if (mode == 'logchannel') {\n\t\t\tmsg.reply(`I didn't see you mention a valid channel. Please mention a channel to send log messages to.`);\n\t\t} else {\n\t\t\tif (logchannel) { logchannel.send(`There has been an error setting up the Bad Words System.`); }\n\t\t}\n\t} else if (membertierone && !(selftierone || selftiertwo)) {\n\t\t// Command author has perms, but bot doesn't.\n\t\tmsg.reply(`Sorry, but I don't have the right permissions to config this system. I require kick, ban, and manage messages permissions to config this filter.`);\n\t} else {\n\t\t// Command author doesn't have the perms needed.\n\t\tmsg.reply(`Sorry, you don't have the right permissions to use this command. You require the **ADMINISTRATOR** and/or the **MANAGE_GUILD** permission(s) to config this filter. Have a higher-up do this for you.`);\n\t}\n}",
      "storage": "0",
      "varName": "",
      "name": "Run Script"
    }
  ],
  "comType": "0",
  "_aliases": []
}
