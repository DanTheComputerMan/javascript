{
  "name": "BadWordsSetup",
  "permissions": "NONE",
  "restriction": "1",
  "_id": "ghoTP",
  "actions": [
    {
      "comment": "DON'T touch this, use the command itself to config the system.",
      "color": "#ff8040",
      "name": "Comment"
    },
    {
      "behavior": "0",
      "interpretation": "1",
      "code": "// Javascript code here. Do NOT edit this or you WILL break it.\nconst WrexMODS = this.getWrexMods();\nconst db = WrexMODS.require('quick.db');\n\n// Example/sample word list in case you don't one already set up.\nvar wordlist = db.get(`servers.${server.id}.badwordsystem.badwordlist`) || [`anal`, `anus`, `arse`, `ass`, `ballsack`, `balls`, `bastard`, `bitch`, `blowjob`, `blow job`, `boner`, `boob`, `clitoris`, `cock`, `coon`, `cunt`, `damn`, `dick`, `dildo`, `dyke`, `fag`, `fellate`, `fellatio`, `fuck`, `goddamn`, `god damn`, `hell`, `homo`, `jizz`, `labia`, `nigga`, `nigger`, `penis`, `pube`, `pussy`, `queer`, `scrotum`, `sex`, `shit`, `slut`, `smegma`, `tit`, `twat`, `vagina`, `wank`, `whore`];\nconst onoff = db.get(`servers.${server.id}.badwordsystem.status`) || false;\nconst logchannel = bot.channels.get(String(db.get(`servers.${server.id}.badwordsystem.logchannelID`))) || false;\n\nfunction trim(str) { // Trims leading and trailing spaces from a string.\n\treturn str.replace(/^\\s+|\\s+$/gm,'');\n}\n\nfunction ConvArrToObj(array) { // Converts default bad word list to an object format.\n\tlet a = array.map(bword => (typeof(bword) != 'object') ? Object.assign({ word: String(bword), action: 'delete' }) : bword); // sets entries that are not in array format to themselves (i.e. ones that have already been converted to object format.)\n\tfor (var i in a) { // Converts {} empty objects to < empty item > so that boolean check below can work.\n\t\tif (!a[i] || typeof a[i] !== \"object\") {\n\t\t\tcontinue // If null or not an object, skip to the next iteration\n\t\t}\n\t\t\n\t\t// The property is an object\n\t\tif (Object.keys(a[i]).length === 0) {\n\t\t\tdelete a[i]; // The object had no properties, so delete that property\n\t\t}\n\t}\n\treturn a.filter(Boolean); // Removes {} empty objects.\n}\n\n// For every function part.     Bigger array, smaller array.    It's a function, so call it like checker(bigger_arr, smaller_arr);\nvar checker = (arr, target) => target.every(p => arr.includes(p));\n\nconst prefix = (server && server.tag) || this.getDBM().Files.data.settings.tag;\nconst args = msg.content.slice(prefix.length).trim().split(/ +/g); \nconst command = args[0]; args.shift();\n\nconst nickname = msg.member.displayName;\n\nconst bossperms = ['ADMINISTRATOR', 'MANAGE_GUILD'];\nconst regperms = ['BAN_MEMBERS', 'KICK_MEMBERS', 'MANAGE_MESSAGES'];\nconst self = server.me; var permArr = [];\n\nvar selfperms = self.permissions.serialize();\nlet selperm = Object.entries(selfperms);\nvar memberperms = member.permissions.serialize();\nlet memperm = Object.entries(memberperms);\n\n// Gets permissions that are true.\nfor (i = 0; i < Object.keys(selfperms).length; i++) {\n  if (selperm[i][1] === true) {\n    permArr.push(selperm[i][0]);\n  }\n}\nvar selftierone = permArr.some(p=> bossperms.indexOf(p) >= 0);\nvar selftiertwo = (selfperms, regperms) => regperms.every(p => selfperms.includes(p));\n\npermArr = [];\nfor (i = 0; i < Object.keys(memberperms).length; i++) {\n  if (memperm[i][1] === true) {\n    permArr.push(memperm[i][0]);\n  }\n}\nvar membertierone = permArr.some(p=> bossperms.indexOf(p) >= 0);\n\n\n\nif (!args[0]) {\n\tmsg.channel.send(`Command Usage:\n**${prefix}${command} check**\n**${prefix}${command} enable**\n**${prefix}${command} disable**\n**${prefix}${command} addwords wordone | word two | \"word three\" as a quote**\n**${prefix}${command} delwords wordone | word two | \"word three\" as a quote**\n**${prefix}${command} logchannel [mentioned channel]**\nExample:\n**${prefix}${command} logchannel #bot-output**`);\n} else if (!(['check', 'enable', 'disable', 'addwords', 'delwords', 'logchannel'].includes(args[0]))) {\n\tmsg.reply(`you must provide a valid option. The options are as follows:\n**${prefix}${command} check**\n**${prefix}${command} enable**\n**${prefix}${command} disable**\n**${prefix}${command} addwords**\n**${prefix}${command} delwords**\n**${prefix}${command} logchannel [mentioned channel]**`);\n} else {\n\tvar mode = args[0];\n\tif (membertierone && (selftierone || selftiertwo)) {\n\t\t// both command author and bot have perms, and user can set this up.\n\t\tif (mode == 'check') {\n\t\t\tmsg.reply(`The system is currently ${(onoff == true) ? \"enabled\" : \"disabled\"}.`);\n\t\t} else if (mode == 'enable') { // enabling code\n\t\t\tif (onoff == true) {\n\t\t\t\tmsg.reply(\"System is already enabled!\");\n\t\t\t} else {\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.status`, true)\n\t\t\t\tmsg.reply(`Bad Word System has been enabled. To disable this later, just run **${prefix}${command} disable**. ${(logchannel) ? \"\" : \"Remember to set the log channel!\"}`);\n\t\t\t}\n\t\t} else if (mode == 'disable') { // disabling code\n\t\t\tif (onoff == false) {\n\t\t\t\tmsg.reply(\"System is already disabled!\");\n\t\t\t} else {\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.status`, false)\n\t\t\t\tmsg.reply(`Bad Word System has been disabled. To enable this later, just run **${prefix}${command} enable**.`);\n\t\t\t}\n\t\t} else if (mode == 'delwords') {\n\t\t\tvar oldwordarr = []; let user_typed_words_check = args; user_typed_words_check.shift(); \n\t\t\tif (user_typed_words_check.length <= 0) {\n\t\t\t\tmsg.channel.send(`${nickname}, you didn't type any words to delete!`);\n\t\t\t} else {\n\t\t\t\targs.join(' ').trim().split(/\\|/g).forEach(function(element) { oldwordarr.push(trim(element)); });\n\t\t\t\tvar wordlisttwo = wordlist.filter(b=>b.word).map(b=>b.word.toLowerCase()); // Removes all regular ojects from array and leaves objects for what's left ({word: 'example', action: 'delete'}, {word: 'testing', action: 'ban'}, etc)\n\t\t\t\tvar wordlistthree = wordlist.filter(b=>!b.word).map(b=>b.word.toLowerCase()); // Removes all objects from array and leaves regular entries for what's left ('fuck', 'shit', etc).\n\t\t\t\tvar wordlistfour = wordlisttwo.concat(wordlistthree); // All words stored in wordlist. Now I need to compare them, and not remove words that aren't already there. Once I have a list of all words to remove, I remove them from the wordlistfour variable. Then I need to run a findindex or whatever to find the word in the main badwordlist and add/push it back with the appropriate disciplinary action.\n\t\t\t\tfunction appendObjTo(thatArray, newObj) { // Adds objects { word: 'word', action: 'delete' } to an array.\n\t\t\t\t\treturn thatArray.concat(newObj);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < wordlistfour.length; i++) {\n\t\t\t\t\tif (oldwordarr.includes(wordlistfour[i])) {\n\t\t\t\t\t\twordlistfour.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Okay, now that all words the user wanted removed are removed, set the list back up where\n\t\t\t\t// each remaining word has its appropriate disciplinary action back.\n\t\t\t\toldwordarr = [];\n\t\t\t\tfor (var i = 0; i < wordlistfour.length; i++) {\n\t\t\t\t\toldwordarr = appendObjTo(oldwordarr, {word: wordlistfour[i], action: Object.entries(wordlist.find(bword => String(bword.word).toLowerCase() === wordlistfour[i]))[1][1]} ); // Adds the word back with the appropriate disciplinary action.\n\t\t\t\t}\n\t\t\t\twordlist = oldwordarr; // Now contains the updated bad word object array with removed words.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.badwordlist`, wordlist); // Saves word list with removed words back to the saved word list.\n\t\t\t\t\n\t\t\t\tmsg.channel.send(`Removed all applicable words from the bad word list for this server.`);\n\t\t\t}\n\t\t} else if (mode == 'addwords') {\n\t\t\tvar oldwordarr = []; let user_typed_words_check = args; user_typed_words_check.shift(); \n\t\t\tif (user_typed_words_check.length <= 0) { // user didn't type any words\n\t\t\t\tmsg.channel.send(`${nickname}, you didn't type any words to add!`);\n\t\t\t} else {\n\t\t\t\tvar newwordarr = []; var newwordarrtwo = [];\n\t\t\t\targs.join(' ').trim().split(/\\|/g).forEach(function(element) { newwordarr.push(trim(element)); });\n\t\t\t\t\n\t\t\t\tvar wordlisttwo = wordlist.filter(b=>b.word).map(b=>b.word.toLowerCase()); // Removes all regular ojects from array and leaves objects for what's left ({word: 'example', action: 'delete'}, {word: 'testing', action: 'ban'}, etc)\n\t\t\t\tvar wordlistthree = wordlist.filter(b=>!b.word).map(b=>b.word.toLowerCase()); // Removes all objects from array and leaves regular entries for what's left ('pussy', 'cunt', etc).\n\t\t\t\tvar wordlistfour = wordlisttwo.concat(wordlistthree); // All words stored in wordlist. Now I need to compare them, and add words that aren't already there. Once I have a list of all words to add, I add them to the wordlistfour variable. Then I need to run a findindex or whatever to find the word in the main badwordlist and add/push it back with the appropriate disciplinary action.\n\t\t\t\t\n\t\t\t\tfunction appendObjTo(thatArray, newObj) { // Adds objects { word: 'word', action: 'delete' } to an array.\n\t\t\t\t\treturn thatArray.concat(newObj);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < newwordarr.length; i++) {\n\t\t\t\t\tif (!(wordlistfour.includes(newwordarr[i]))) {\n\t\t\t\t\t\tnewwordarrtwo = appendObjTo(newwordarrtwo, {word: newwordarr[i], action: 'delete'} ); // Adds the word with the delete disciplinary action. Will allow customizability later.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Now newwordarrtwo contains all new words they want, and in object format. I now need to convert wordlistfour variable to object format with the appropriate disciplinary action. After that, concatenate the two and save it back to quick.db\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// Okay, now that all words the user wanted removed are removed, set the list back up where\n\t\t\t\t// each remaining word has its appropriate disciplinary action back.\n\t\t\t\tnewwordarr = [];\n\t\t\t\tfor (var i = 0; i < wordlistfour.length; i++) {\n\t\t\t\t\toldwordarr = appendObjTo(oldwordarr, {word: wordlistfour[i], action: Object.entries(wordlist.find(bword => String(bword.word).toLowerCase() === wordlistfour[i]))[1][1]} ); // Adds the word back with the appropriate disciplinary action.\n\t\t\t\t}\n\t\t\t\twordlist = oldwordarr; // Now contains original badword list.\n\t\t\t\twordlist = wordlist.concat(newwordarrtwo); // Now contains the updated bad word object array with the added words.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.badwordlist`, wordlist)\n\t\t\t\t\n\t\t\t\tmsg.channel.send(`Added all applicable words to the bad word list for this server.`);\n\t\t\t}\n\t\t} else if ((mode == 'logchannel') && !args[1]) {\n\t\t\tmsg.reply(`${(logchannel) ? \"Log channel is currently set as: \"+logchannel : \"No log channel set, please mention a log channel to set it to.\"}`);\n\t\t} else if ((mode == 'logchannel') && (msg.mentions && msg.mentions.channels && msg.mentions.channels.first())) {\n\t\t\t// code\n\t\t\tdb.set(`servers.${server.id}.badwordsystem.logchannelID`, msg.mentions.channels.first().id);\n\t\t\tmsg.reply(`Log channel successfully set to ${msg.mentions.channels.first()}.`);\n\t\t} else if (mode == 'logchannel') {\n\t\t\tmsg.reply(`I didn't see you mention a valid channel. Please mention a channel to send log messages to.`);\n\t\t} else {\n\t\t\tif (logchannel) { logchannel.send(`There has been an error setting up the Bad Words System.`); }\n\t\t}\n\t} else if (membertierone && !(selftierone || selftiertwo)) {\n\t\t// Command author has perms, but bot doesn't.\n\t\tmsg.reply(`Sorry, but I don't have the right permissions to config this system. I require kick, ban, and manage messages permissions to config this filter.`);\n\t} else {\n\t\t// Command author doesn't have the perms needed.\n\t\tmsg.reply(`Sorry, you don't have the right permissions to use this command. You require the **ADMINISTRATOR** and/or the **MANAGE_GUILD** permission(s) to config this filter. Have a higher-up do this for you.`);\n\t}\n}",
      "storage": "0",
      "varName": "",
      "name": "Run Script"
    }
  ],
  "comType": "0",
  "_aliases": []
}
