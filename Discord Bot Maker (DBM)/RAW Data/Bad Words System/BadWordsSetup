{
  "name": "BadWordsSetup",
  "permissions": "NONE",
  "restriction": "1",
  "_id": "ghoTP",
  "actions": [
    {
      "behavior": "0",
      "interpretation": "1",
      "code": "// Javascript code here. Do NOT edit this or you will likely break it.\nconst WrexMODS = this.getWrexMods();\nconst db = WrexMODS.require('quick.db');\n// Create a sample word list in case none exists. Please don't directly edit this; just use the command itself.\nvar wordlist = db.get(`servers.${server.id}.badwordsystem.badwordlist`) || [`anal`, `anus`, `arse`, `ass`, `ballsack`, `balls`, `bastard`, `bitch`, `blowjob`, `blow job`, `boner`, `boob`, `clitoris`, `cock`, `coon`, `cunt`, `damn`, `dick`, `dildo`, `dyke`, `fag`, `fellate`, `fellatio`, `fuck`, `goddamn`, `god damn`, `hell`, `homo`, `jizz`, `labia`, `nigga`, `nigger`, `penis`, `pube`, `pussy`, `queer`, `scrotum`, `sex`, `shit`, `slut`, `smegma`, `tit`, `twat`, `vagina`, `wank`, `whore`];\nconst onoff = db.get(`servers.${server.id}.badwordsystem.status`) || false;\nconst logchannel = bot.channels.get(String(db.get(`servers.${server.id}.badwordsystem.logchannelID`))) || false;\n\nfunction trim(str) { // Trims leading and trailing spaces from a string.\n\treturn str.replace(/^\\s+|\\s+$/gm,'');\n}\n\nfunction ConvArrToObj(array) { // Converts default bad word list to an object format.\n\tlet a = array.map(bword => (typeof(bword) != 'object') ? Object.assign({ word: String(bword), action: 'delete' }) : bword); // sets entries that are not in array format to themselves (i.e. ones that have already been converted to object format.)\n\tfor (var i in a) { // Converts {} empty objects to < empty item > so that boolean check below can work.\n\t\tif (!a[i] || typeof a[i] !== \"object\") {\n\t\t\tcontinue // If null or not an object, skip to the next iteration\n\t\t}\n\t\t\n\t\t// The property is an object\n\t\tif (Object.keys(a[i]).length === 0) {\n\t\t\tdelete a[i]; // The object had no properties, so delete that property\n\t\t}\n\t}\n\treturn a.filter(Boolean); // Removes {} empty objects.\n}\n\n// For every function part.\nvar checker = (arr, target) => target.every(p => arr.includes(p));\nconst usertype = db.get(`servers.${server.id}.badwordsystem.usertype`) || '@mention'; // @mention or usertag display on msg deletion log.\n\nconst configtypes = ['usertype', 'wordtype'];\n\nconst args = msg.content.slice((server && server.tag) || this.getDBM().Files.data.settings.tag.length).trim().split(/ +/g); \nconst command = args[0]; args.shift();\n// var prefix = (server && server.tag) || this.getDBM().Files.data.settings.tag;\n\n\nconst bossperms = ['ADMINISTRATOR', 'MANAGE_GUILD'];\nconst regperms = ['BAN_MEMBERS', 'KICK_MEMBERS', 'MANAGE_MESSAGES'];\nconst self = server.me; var permArr = [];\n\nvar selfperms = self.permissions.serialize();\nlet selperm = Object.entries(selfperms);\nvar memberperms = member.permissions.serialize();\nlet memperm = Object.entries(memberperms);\n\n// Gets permissions that are true.\nfor (i = 0; i < Object.keys(selfperms).length; i++) {\n  if (selperm[i][1] === true) {\n    permArr.push(selperm[i][0]);\n  }\n}\nvar selftierone = permArr.some(p=> bossperms.indexOf(p) >= 0);\nvar selftiertwo = (selfperms, regperms) => regperms.every(p => selfperms.includes(p));\n\npermArr = [];\nfor (i = 0; i < Object.keys(memberperms).length; i++) {\n  if (memperm[i][1] === true) {\n    permArr.push(memperm[i][0]);\n  }\n}\nvar membertierone = permArr.some(p=> bossperms.indexOf(p) >= 0);\n\n\n\n\nif (!args[0]) {\n\tmsg.channel.send(`Command Usage:\n**${command} guide**\n**${command} check**\n**${command} enable**\n**${command} disable**\n**${command} config**\n**${command} addwords**\n**${command} delwords**\n**${command} logchannel [mentioned channel]**\nExample:\n**${command} logchannel #bot-output**`);\n} else if (!(['guide', 'check', 'enable', 'disable', 'config', 'addwords', 'delwords', 'logchannel'].includes(args[0]))) {\n\tmsg.reply(`you must provide a valid option. The options are as follows:\n**${command} guide**\n**${command} check**\n**${command} enable**\n**${command} disable**\n**${command} config**\n**${command} addwords**\n**${command} delwords**\n**${command} logchannel [mentioned channel]**`);\n} else {\n\tvar mode = args[0];\n\tif (membertierone && (selftierone || selftiertwo)) {\n\t\t// both command author and bot have perms, and user can set this up.\n\t\tif (mode == 'guide') {\n\t\t\tmsg.reply(`the guide on how to use this system is linked here: https://github.com/DanTheComputerMan/javascript/blob/master/Discord%20Bot%20Maker%20(DBM)/RAW%20Data/Bad%20Words%20System/readme.md`);\n\t\t} else if (mode == 'check') {\n\t\t\t// msg.reply(`The system is currently ${(Files.data.servers[String(server.id)]['bad_words_system'] == true) ? \"enabled\" : \"disabled\"}.`);\n\t\t\tmsg.reply(`the system is currently ${(onoff == true) ? \"enabled\" : \"disabled\"}.`);\n\t\t} else if (mode == 'enable') { // enabling code\n\t\t\tif (onoff == true) {\n\t\t\t\tmsg.reply(\"the system is already enabled!\");\n\t\t\t} else {\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.status`, true)\n\t\t\t\tmsg.reply(`Bad Word System has been enabled. To disable this later, just run **${command} disable**. ${(logchannel) ? \"\" : \"Remember to set the log channel!\"}`);\n\t\t\t}\n\t\t} else if (mode == 'disable') { // disabling code\n\t\t\tif (onoff == false) {\n\t\t\t\tmsg.reply(\"the system is already disabled!\");\n\t\t\t} else {\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.status`, false)\n\t\t\t\tmsg.reply(`Bad Word System has been disabled. To enable this later, just run **${command} enable**.`);\n\t\t\t}\n\t\t} else if (mode == 'config') { // multiple configuration options including @mention or usertag option.\n\t\t\tlet usersubtype = ['check', '@mention', 'usertag']; let wordsubtype = ['check', 'matchany', 'matchanycasingmatters', 'matchword', 'matchwordcasingmatters'];\n\t\t\tlet allsubtypes = usersubtype.concat(wordsubtype);\n\t\t\tif (!args[1] || !configtypes.includes(args[1])) { \n\t\t\t\tmsg.reply(`you must select a configuration option. The options are as follows: **\\`usertype\\`, \\`wordtype\\`**`);\n\t\t\t} else if (!args[2] || !allsubtypes.includes(args[2])) {\n\t\t\t\t// Yes, b/c of the escaped ` symbols, it looks wierd.\n\t\t\t\tmsg.reply(`you must select a configuration sub-type. ${(args[1]=='usertype') ? \"The options are as follows: **\\`\"+usersubtype.join('\\`**, **\\`') : (args[1]=='wordtype') ? \"The options are as follows: **\\`\"+wordsubtype.join('\\`**, **\\`') : \"You didn't select a valid configuration option.\"}\\`**`)\n\t\t\t\t// `\n\t\t\t} else {\n\t\t\t\t\tconsole.log('switch statement');\n\t\t\t\tswitch (args[1]) {\n\t\t\t\t\tcase \"usertype\":\n\t\t\t\t\t\tif (args[2].match(/check/i)) {\n\t\t\t\t\t\t\tmsg.reply(`the system is currently set as **\\`${db.get(`servers.${server.id}.badwordsystem.usertype`) || '@mention'}\\`**.`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(args[2].match(/@?(user|u)?mention/)) ? db.set(`servers.${server.id}.badwordsystem.usertype`, '@mention') : (args[2].match(/(user|u)?tag/)) ? db.set(`servers.${server.id}.badwordsystem.usertype`, 'usertag') : null\n\t\t\t\t\t\t\tmsg.reply(`${(args[2] == 'check') ? `the usertype is currently set as **\\`${usertype}\\`**.` : (args[2].match(/@?(user|u)?mention/)) ? \"successfully set the usertype to @mention instead of tag (Rando#1234).\" : (args[2].match(/(user|u)tag/)) ? \"successfully set the usertype to user tag (Rando#1234) instead of @mention. Enjoy not having the pings.\" : \"you need to choose either **`@mention`** or **`usertag`** option.\" }`)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase \"wordtype\":\n\t\t\t\t\t\tif (args[2].match(/check/i)) {\n\t\t\t\t\t\t\tmsg.reply(`the system is currently set as **\\`${db.get(`servers.${server.id}.badwordsystem.wordtype`) || 'matchany'}\\`**.`)\n\t\t\t\t\t\t} else if (args[2].match(/match(any|anycasingmatters|word|wordcasingmatters)/i)) {\n\t\t\t\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.wordtype`, String(args[2].match(/match(any|anycasingmatters|word|wordcasingmatters)/i)[0]).toLowerCase())\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.shift(); args.shift(); \n\t\t\t\t\t\t\tmsg.reply(`**${args.join(' ')}** wasn't a valid subtype. The valid subtypes are ${wordsubtype.join(', ')}.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmsg.reply(`that wasn't a valid configuration option. The options are as follows: **\\`${allsubtypes.join(' ')}\\`**`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t// Features still in development:\n\t\t\t\t\t//case \"matchtype\":\n\t\t\t\t\t\t\n\t\t\t\t\t\t//break;\n\t\t\t\t\t\t\n\t\t\t\t\t//case \"regexflag\":\n\t\t\t\t\t\t\n\t\t\t\t\t\t//break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else if (mode == 'delwords') {\n\t\t\tif (args[1]) {\n\t\t\t\tvar oldwordarr = [];\n\t\t\t\targs.shift(); args.join(' ').trim().split('|').forEach(function(element) { oldwordarr.push(trim(element)); });\n\t\t\t\tconsole.log('oldwordarr for delwords is: '+oldwordarr);\n\t\t\t\tvar wordlisttwo = wordlist.filter(b=>b.word).map(b=>trim(b.word.toLowerCase())); // Removes all regular ojects from array and leaves objects for what's left ({word: 'example', action: 'delete'}, {word: 'testing', action: 'ban'}, etc)\n\t\t\t\tvar wordlistthree = wordlist.filter(b=>!b.word).map(b=>trim(b.toLowerCase())); // Removes all objects from array and leaves regular entries for what's left ('pussy', 'cunt', etc).\n\t\t\t\tvar wordlistfour = wordlisttwo.concat(wordlistthree); // All words stored in wordlist. Now I need to compare them, and not remove words that aren't already there. Once I have a list of all words to remove, I remove them from the wordlistfour variable. Then I need to run a findindex or whatever to find the word in the main badwordlist and add/push it back with the appropriate disciplinary action.\n\t\t\t\tfunction appendObjTo(thatArray, newObj) { // Adds objects { word: 'word', action: 'delete' } to an array.\n\t\t\t\t\treturn thatArray.concat(newObj);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i <= wordlistfour.length; i++) {\n\t\t\t\t\tif (oldwordarr.includes(trim(wordlistfour[i]))) {\n\t\t\t\t\t\twordlistfour.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Okay, now that all words the user wanted removed are removed, set the list back up where\n\t\t\t\t// each remaining word has its appropriate disciplinary action back.\n\t\t\t\toldwordarr = [];\n\t\t\t\tfor (var i = 0; i < wordlistfour.length; i++) {\n\t\t\t\t\toldwordarr = appendObjTo(oldwordarr, {word: wordlistfour[i], action: Object.entries(wordlist.find(bword => String(bword.word).toLowerCase() === wordlistfour[i]))[1][1]} ); // Adds the word back with the appropriate disciplinary action.\n\t\t\t\t}\n\t\t\t\twordlist = oldwordarr; // Now contains the updated bad word object array with removed words.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.badwordlist`, wordlist); // Saves word list with removed words back to the saved word list.\n\t\t\t\t\n\t\t\t\tmsg.reply(`removed all applicable words from the bad word list for this server if they existed.`);\n\t\t\t} else {\n\t\t\t\tmsg.reply(`you need to specify words you want removed from the bad word list for this server.`);\n\t\t\t}\n\t\t} else if (mode == 'addwords') {\n\t\t\tif (args[1]) { // Ensures the user typed at least 1 word to add.\n\t\t\t\tlet actions = ['delete', 'kick', 'ban']\n\t\t\t\tvar newwordarr = String(args.join(' ').trim()).split('|'); var newwordarrtwo = []; var actualwordstoadd = [];\n\t\t\t\tfor (i=0; i<newwordarr.length; i++) {\n\t\t\t\t\tlet w = String(newwordarr[i]).split(\":\");\n\t\t\t\t\t// To ensure bs action '69 lol lol lol, Im so edgy' or whatever else doesn't happen.\n\t\t\t\t\tnewwordarrtwo = newwordarrtwo.concat({'word' : (w[2] || (w[1] && !actions.includes(w[1]))) ? w.slice(0, w.length-1).join(':').trim() : w[0].trim(), 'action': (actions.includes(String(w[1]))) ? w[1].trim() : 'delete'});  // In short, if user's word to add has a : in it, still allow that as well. For example:\t\t\t12:30:delete\tmakes '12:30' a bad phrase with delete the action to take.\n\t\t\t\t}\n\t\t\t\twordlist = wordlist.concat(newwordarrtwo); // wordlist now contains the object with all the new words and the appropriate disciplinary action to take, as well as all previously existing words.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// The purpose of these 3 steps below is to help make the system more DBM user resistant.\n\t\t\t\tvar wordlisttwo = wordlist.filter(b=>b.word).map(b=>b.word.toLowerCase()); // Removes all regular ojects from array and leaves objects for what's left ({word: 'example', action: 'delete'}, {word: 'testing', action: 'ban'}, etc). This stores the resulting list in array form, with the only the 'word' properties shown for each element.\n\t\t\t\tvar wordlistthree = wordlist.filter(b=>!b.word).map(b=>b.toLowerCase()); // Removes all objects from array and leaves regular entries for what's left ['pussy', 'cunt', 'etc'].\n\t\t\t\tvar wordlistfour = wordlisttwo.concat(wordlistthree); // All words stored in wordlist. Now I need to compare them, and add words that aren't already there. Once I have a list of all words to add, I add them to the wordlistfour variable. Then I need to run a findindex or whatever to find the word in the main badwordlist and add/push it back with the appropriate disciplinary action.\n\t\t\t\tvar tempwordlist = [];\n\t\t\t\tfunction appendObjTo(thatArray, newObj) { // Adds objects { word: 'word', action: 'delete' } to an array.\n\t\t\t\t\treturn thatArray.concat(newObj);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlet singular = list => [...new Set(list)];\n\t\t\t\twordlistfour = singular(wordlistfour); // Makes sure wordlistfour doesn't contain any duplicates.\n\t\t\t\t\n\t\t\t\t// Now I need to add the appropriate disciplinary actions back.\n\t\t\t\tfor (i=0; i<wordlistfour.length; i++) {\n\t\t\t\t\tlet act = Object.entries(wordlist.find(bword => String(bword.word).toLowerCase() === wordlistfour[i]))[1][1];\n\t\t\t\t\ttempwordlist = appendObjTo(wordlistfour, {'word': wordlistfour[i], 'action': (act.length > 1) ? act : 'delete'} ); // Adds the word with the appropriate disciplinary action or 'delete' if none exists. The greater than 1 bit is to ensure that it doesn't cause only the first character to pop up, as can happen if not done this way.\n\t\t\t\t} // tempwordlist now contains all new words the user wants added, with the appropriate disciplinary action (re-)applied.\n\t\t\t\t\n\t\t\t\twordlist = tempwordlist;\n\t\t\t\tdb.set(`servers.${server.id}.badwordsystem.badwordlist`, wordlist)\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmsg.channel.send(`Added all applicable words to the bad word list for this server.`);\n\t\t\t} else {\n\t\t\t\tmsg.reply(`you need to specify words you want removed from the bad word list for this server.`);\n\t\t\t}\n\t\t} else if ((mode == 'logchannel') && (!args[1] || (args[1] && args[1]==\"check\"))) {\n\t\t\tmsg.reply(`${(logchannel) ? \"log channel is currently set as: \"+logchannel : \"no log channel set, please mention a log channel to set it to.\"}`);\n\t\t} else if ((mode == 'logchannel') && (msg.mentions && msg.mentions.channels && msg.mentions.channels.first())) {\n\t\t\tdb.set(`servers.${server.id}.badwordsystem.logchannelID`, msg.mentions.channels.first().id);\n\t\t\tmsg.reply(`log channel successfully set to ${msg.mentions.channels.first()}.`);\n\t\t} else if (mode == 'logchannel') {\n\t\t\tmsg.reply(`I didn't see you mention a valid channel. Please mention a channel to send log messages to.`);\n\t\t} else {\n\t\t\tif (logchannel) { logchannel.send(`There has been an error setting up the Bad Words System.`); }\n\t\t}\n\t} else if (membertierone && !(selftierone || selftiertwo)) {\n\t\t// Command author has perms, but bot doesn't.\n\t\tmsg.reply(`sorry, but I don't have the right permissions to config this system. I require \\`kick\\`, \\`ban\\`, and \\`manage messages\\` permissions to config this filter.`);\n\t} else {\n\t\t// Command author doesn't have the perms needed.\n\t\tmsg.reply(`sorry, but you don't have the right permissions to use this command. You require the **\\`administrator\\`** and/or the **\\`manage guild\\`** permission(s) to config this filter. Have a higher-up do this for you.`);\n\t}\n}",
      "storage": "0",
      "varName": "",
      "name": "Run Script"
    }
  ],
  "comType": "0"
}
