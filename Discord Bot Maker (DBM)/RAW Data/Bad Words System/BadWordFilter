{
  "name": "BadWordFilter",
  "permissions": "NONE",
  "restriction": "1",
  "_id": "QSGIQ",
  "actions": [
    {
      "code": "// Javascript code here. Do NOT edit this or you will likely break it.\n(() => {\n\tconst ensure = this.getMods().require;\n\tconst db = ensure('quick.db');\n\tconst { parse, stringify } = JSON5 = ensure('json5');\n\t\n\t// createPath(['triangle', 'points'], obj, 3);\n\tfunction ensurePath(path, obj, def) { // def = default value (optional; defaults to empty object). Built in checking if object already exists. If it does not exist, creates the path.\n\t\tfor(let i = 0; i < path.length; i++) {\n\t\t\tobj = obj[path[i]] = obj[path[i]] || ((def !== undefined && (i === path.length - 1)) ? def : {});\n\t\t}\n\t}\n\t\n\tfunction trim(str) { // Trims leading and trailing spaces from a string.\n\t\treturn str.replace(/^\\s+|\\s+$/gm,'');\n\t}\n\t\n\tfunction formatText(str, len=1900) {\n\t\treturn trim(str).replace(/\\*/g, '\\\\*').replace(/_/g, '\\\\_').slice(0, len);\n\t}\n\t\n\tconst badwordsystem = db.get(`servers.${msg.guild.id}.badwordsystem`) || {};\n\t\n\tconst enabled = badwordsystem.status;\n\t\n\t// If not enabled, do nothing. DBM doesn't allow for \"if (!enabled) return;\"\n\tif (!enabled) { cache.index += 1; return Actions.callNextAction(cache); }\n\t\n\t// if (enabled) {\n\t// This is just a starting bad word list.\n\tconst wordlist = (badwordsystem.badwordlist && badwordsystem.badwordlist.length !== 0) ? badwordsystem.badwordlist : [{\"word\":\"anal\"},{\"word\":\"anus\"},{\"word\":\"arse\"},{\"word\":\"ass\"},{\"word\":\"asshole\"},{\"word\":\"ballsack\"},{\"word\":\"balls\"},{\"word\":\"bastard\"},{\"word\":\"bitch\"},{\"word\":\"blowjob\"},{\"word\":\"blow job\"},{\"word\":\"boner\"},{\"word\":\"boob\"},{\"word\":\"clit\"},{\"word\":\"clitoris\"},{\"word\":\"cock\"},{\"word\":\"coon\"},{\"word\":\"cunnilingus\"},{\"word\":\"cunt\"},{\"word\":\"damn\"},{\"word\":\"dick\"},{\"word\":\"dildo\"},{\"word\":\"dyke\"},{\"word\":\"fag\"},{\"word\":\"faggot\"},{\"word\":\"fellate\"},{\"word\":\"fellatio\"},{\"word\":\"fuck\"},{\"word\":\"goddamn\"},{\"word\":\"god damn\"},{\"word\":\"hell\"},{\"word\":\"homo\"},{\"word\":\"jizz\"},{\"word\":\"labia\"},{\"word\":\"nigga\"},{\"word\":\"nigger\"},{\"word\":\"penis\"},{\"word\":\"pube\"},{\"word\":\"pussy\"},{\"word\":\"queer\"},{\"word\":\"scrotum\"},{\"word\":\"sex\"},{\"word\":\"shit\", \"action\":[\"mute\"]},{\"word\":\"slut\"},{\"word\":\"smegma\"},{\"word\":\"tit\"},{\"word\":\"twat\"},{\"word\":\"vagina\"},{\"word\":\"wank\"},{\"word\":\"whore\"}];\n\t\n\tensurePath(['status'], badwordsystem, false);\n\tensurePath(['config', 'defaults', 'config'], badwordsystem);\n\tensurePath(['config', 'filters', 'channels'], badwordsystem, []);\n\tensurePath(['config', 'filters', 'roles'], badwordsystem, []);\n\tensurePath(['config', 'channels', 'badwordlog'], badwordsystem);\n\tensurePath(['config', 'channels', 'actionlog'], badwordsystem);\n\tensurePath(['config', 'commands', 'disabled'], badwordsystem, []);\n\n\tconst usermode = (badwordsystem.config.defaults.usermode === 'id') ? msg.author.id : (badwordsystem.config.defaults.usermode === 'tag' ? msg.author.tag : msg.author);\n\tconst badwordlogchannel = bot.channels.cache.get(badwordsystem.config.channels.badwordlog.channelid) || ''; // In case no channel exists anymore for the stored ChannelID.\n\tconst actionlogchannel = bot.channels.cache.get(badwordsystem.config.channels.actionlog.channelid) || ''; // In case no channel exists anymore for the stored ChannelID.\n\n\t// Below 3 lines are never used.\n\t// const prefix = (server && server.tag) || this.getDBM().Files.data.settings.tag || \"!\";\n\t// const args = msg.content.slice(prefix.length).trim().split(/ +/g); \n\t// const command = args[0]; args.shift();\n\n\tconst nickname = msg.member.displayName;\n\n\tconst url = `https://github.com/DanTheComputerMan/javascript/tree/master/Discord%20Bot%20Maker%20(DBM)/RAW%20Data/Bad%20Words%20System`;\n\n\tconst em = new DiscordJS.MessageEmbed;\n\tif (badwordsystem.config.defaults.config.timestamp) em.setTimestamp(Date.now());\n\tif (badwordsystem.config.defaults.config.footer) em.setFooter(badwordsystem.config.defaults.config.footer);\n\tif (await isImageURL(badwordsystem.config.defaults.config.imageURL)) em.setImage(badwordsystem.config.defaults.config.imageURL);\n\tif (await isImageURL(badwordsystem.config.defaults.config.thumbnailURL)) em.setThumbnail(badwordsystem.config.defaults.config.thumbnailURL);\n\t\t\n\tem.setURL(url)\n\t\t.setColor(badwordsystem.config.defaults.config.color || 'GREEN')\n\n\tconst matchstyle = badwordsystem.config.defaults.config.matchstyle || \"matchword\";\n\tconst default_mode = badwordsystem.config.defaults.config.mode || {operation: \"standard\"}; // standard, substitution, extended, and regex. Substitution is WIP.\n\tconst default_action = badwordsystem.config.defaults.config.action || [\"delete\"];\n\tconst default_rules = badwordsystem.config.defaults.config.rules || {};\n\tlet actions = []; const words = [];\n\tlet reg;\n\t\n    // If not a whitelisted channel, or not by someone with a whitelisted role, proceed.\n\tif (badwordsystem.config.filters.channels.indexOf(msg.channel.id) !== -1) { cache.index += 1; return Actions.callNextAction(cache); }\n\tif (badwordsystem.config.filters.roles.some(id => msg.member.roles.cache.map(r => r.id).includes(id))) { cache.index += 1; return Actions.callNextAction(cache); }\n\t\n\t// for (let i = 0; i < wordlist.length; i++) {\n\tconst wordsnum = wordlist.length - 1;\n\tfor (let i = wordsnum; i > 0; i--) { // inclusive step. Also, for-loop down to 0 is reportedly faster.\n\t\tlet mode = wordlist[i].mode || default_mode;\n\t\tlet action = wordlist[i].action || default_action;\n\t\t\n\t\t// If in an allowed channel, or by someone with an allowed role, skip.\n\t\tif (wordlist[i].filters && ((wordlist[i].filters.channels && msg.channel.id.indexOf(wordlist[i].filters.channels) !== -1) || (wordlist[i].filters.roles && wordlist[i].filters.roles.some(msg.member.roles)))) continue;\n\t\tif (mode.operation === \"regex\") {\n\t\t\treg = new RegExp(wordlist[i].word, mode.flags || \"\");\n\t\t\tif (reg.test(msg.content.match)) {\n\t\t\t\tactions = actions.concat(action);\n\t\t\t\twords.push(wordlist[i].word);\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (matchstyle) {\n\t\t\t\tcase \"matchregex\":\n\t\t\t\t\treg = new RegExp(wordlist[i].word, mode.flags || \"\");\n\t\t\t\t\tif (reg.test(msg.content.match)) {\n\t\t\t\t\t\tactions = actions.concat(action);\n\t\t\t\t\t\twords.push(wordlist[i].word);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"matchany\":\n\t\t\t\tcase \"matchanycasingmatters\":\n\t\t\t\t\treg = new RegExp(`\\\\b${wordlist[i].word}\\\\b`, (matchstyle === \"matchany\") ? 'i' : '');\n\t\t\t\t\tif (mode.operation === \"standard\" && reg.test(msg.content)) {\n\t\t\t\t\t\tactions = actions.concat(action);\n\t\t\t\t\t\twords.push(wordlist[i].word);\n\t\t\t\t\t} else if (mode.operation === \"extended\") {\n\t\t\t\t\t\treg = new RegExp(wordlist[i].word.replace(/\\?/g, \"[A-Za-z]\").replace(/\\#/g, \"[0-9]\"), (matchstyle === \"matchany\") ? 'i' : '');\n\t\t\t\t\t\tif (reg.test(msg.content)) {\n\t\t\t\t\t\t\tactions = actions.concat(action);\n\t\t\t\t\t\t\twords.push(wordlist[i].word);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"matchword\":\n\t\t\t\tcase \"matchwordcasingmatters\":\n\t\t\t\t\treg = new RegExp(`\\\\b${wordlist[i].word}\\\\b`, (matchstyle === \"matchword\") ? 'i' : '');\n\t\t\t\t\tif (mode.operation === \"standard\" && reg.test(msg.content)) {\n\t\t\t\t\t\tactions = actions.concat(action);\n\t\t\t\t\t\twords.push(wordlist[i].word);\n\t\t\t\t\t} else if (mode.operation === \"extended\") {\n\t\t\t\t\t\treg = new RegExp(wordlist[i].word.replace(/\\?/g, \"[A-Za-z]\").replace(/\\#/g, \"[0-9]\"), (matchstyle === \"matchword\") ? 'i' : '');\n\t\t\t\t\t\tif (reg.test(msg.content)) {\n\t\t\t\t\t\t\tactions = actions.concat(action);\n\t\t\t\t\t\t\twords.push(wordlist[i].word);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (default_rules.BreakOnMatch && words.length === 1) break;\n\t}\n\tif (words.length === 0) { cache.index++; return Actions.callNextAction(cache); } // If there are no words caught, stop.\n\tactions = [...new Set(actions)]; // words = words.filter(Boolean);\n\tconsole.log(words, actions);\n\t\n\t// Now, perform actions. Ex: Delete the message, and mute/kick/ban the user.\n\tif (actions.indexOf('delete') !== -1) {\n\t\tmsg.delete().then(m => {\n\t\t\tem.setDescription(`A message by ${usermode} containing **\\`${words.join(\"`**, **`\")}\\`** deleted from ${m.channel}`);\n\t\t\tbadwordlogchannel && badwordlogchannel.send(em).catch(() => null);\n\t\t\tdefault_rules.PostDeleteMessage && msg.channel.send(`${usermode}'s message was deleted${default_rules.PostDeleteMessageText ? ` for typing **\\`${words.join(\"\\`**, **\\`\")}\\`**` : \"\"}.`);\n\t\t}).catch(() => null);\n\t}\n\tif (actions.indexOf('mute') !== -1) {\n\t\tmsg.guild.roles.fetch(badwordsystem.config.defaults.muterole).then(r => msg.member.roles.add(r)).catch(() => null).then(m => {\n\t\t\tem.setDescription(`${usermode} was muted for typing a message containing **\\`${words.join(\"`**, **`\")}\\`** in ${m.channel}`);\n\t\t\tactionlogchannel && actionlogchannel.send(em).catch(() => null);\n\t\t\tdefault_rules.PostMuteMessage && msg.channel.send(`${usermode} was muted${default_rules.PostMuteMessageText ? ` for typing **\\`${words.join(\"\\`**, **\\`\")}\\`**` : \"\"}.`);\n\t\t}).catch(() => null);\n\t}\n\tif (actions.indexOf('kick') !== -1 && msg.member.kickable) {\n\t\tmsg.author.send(`You have been kicked from the ${msg.guild.name} server for typing: **\\`${words.join(\"`**, **`\")}\\`**`).catch(() => null).then(msg.member.kick()).then(m => {\n\t\t\tem.setDescription(`${usermode} was kicked for typing a message containing **${words.join(\"**, **\")}** in ${m.channel}`);\n\t\t\tactionlogchannel && actionlogchannel.send(em).catch(() => null);\n\t\t\tdefault_rules.PostKickMessage && msg.channel.send(`${usermode} was kicked${default_rules.PostKickMessageText ? ` for typing **\\`${words.join(\"\\`**, **\\`\")}\\`**` : \"\"}.`);\n\t\t}).catch(() => null);\n\t}\n\tif (actions.indexOf('ban') !== -1 && msg.member.bannable) {\n\t\tmsg.author.send(`You have been banned from the ${msg.guild.name} server for typing: **\\`${words.join(\"`**, **`\")}\\`**`).catch(() => null).then(msg.member.ban()).then(m => {\n\t\t\tem.setDescription(`${usermode} was banned for typing a message containing **${words.join(\"**, **\")}** in ${m.channel}`);\n\t\t\tactionlogchannel && actionlogchannel.send(em).catch(() => null);\n\t\t\tdefault_rules.PostBanMessage && msg.channel.send(`${usermode} was banned${default_rules.PostBanMessageText ? ` for typing **\\`${words.join(\"\\`**, **\\`\")}\\`**` : \"\"}.`);\n\t\t}).catch(() => null);\n\t}\n})();",
      "behavior": "1",
      "interpretation": "1",
      "storage": "0",
      "varName": "",
      "VTypeSelect": "0",
      "CVTypeValue": "",
      "name": "Run Script"
    }
  ]
}
