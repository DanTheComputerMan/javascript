{
  "name": "BadWordsFilter",
  "permissions": "NONE",
  "restriction": "1",
  "_id": "AjZlg",
  "actions": [
    {
      "behavior": "0",
      "interpretation": "1",
      "code": "// Javascript code here. Do NOT edit this or you WILL break it. \nconst WrexMODS = this.getWrexMods();\nconst db = WrexMODS.require('quick.db');\n\nconst systemenabledcheck = db.get(`servers.${server.id}.badwordsystem.status`) || false;\n\nif (systemenabledcheck) {\n\tvar messagetext = msg.content;\n\tconst themessage = msg;\n\tconst theUSER = msg.member.user.id;\n\t\n\tvar wordlist = db.get(`servers.${server.id}.badwordsystem.badwordlist`);\n\t\n\t// Below is a basic starter word list if none exist(s): \n\tif(!wordlist) { wordlist = [ {word: 'anal', action: 'delete'}, {word: 'anus', action: 'delete'}, {word: 'arse', action: 'delete'}, {word: 'ass', action: 'delete'}, {word: 'ballsack', action: 'delete'}, {word: 'balls', action: 'delete'}, {word: 'bastard', action: 'delete'}, {word: 'bitch', action: 'delete'}, {word: 'blowjob', action: 'delete'}, {word: 'blow job', action: 'delete'}, {word: 'boner', action: 'delete'}, {word: 'boob', action: 'delete'}, {word: 'clitoris', action: 'delete'}, {word: 'cock', action: 'delete'}, {word: 'coon', action: 'delete'}, {word: 'cunt', action: 'delete'}, {word: 'damn', action: 'delete'}, {word: 'dick', action: 'delete'}, {word: 'dildo', action: 'delete'}, {word: 'dyke', action: 'delete'}, {word: 'fag', action: 'delete'}, {word: 'fellate', action: 'delete'}, {word: 'fellatio', action: 'delete'}, {word: 'fuck', action: 'delete'}, {word: 'goddamn', action: 'delete'}, {word: 'god damn', action: 'delete'}, {word: 'hell', action: 'delete'}, {word: 'homo', action: 'delete'}, {word: 'jizz', action: 'delete'}, {word: 'labia', action: 'delete'}, {word: 'nigga', action: 'delete'}, {word: 'nigger', action: 'delete'}, {word: 'penis', action: 'delete'}, {word: 'pube', action: 'delete'}, {word: 'pussy', action: 'delete'}, {word: 'queer', action: 'delete'}, {word: 'scrotum', action: 'delete'}, {word: 'sex', action: 'delete'}, {word: 'shit', action: 'delete'}, {word: 'slut', action: 'delete'}, {word: 'smegma', action: 'delete'}, {word: 'tit', action: 'delete'}, {word: 'twat', action: 'delete'}, {word: 'vagina', action: 'delete'}, {word: 'wank', action: 'delete'}, {word: 'whore', action: 'delete'} ]; }\n\t// Forces to object format first, just in case.\n\twordlist = wordlist.map(bword => (typeof(bword) != 'object') ? Object.assign({ word: String(bword), action: 'delete' }) : bword);\n\t\n\tdb.set(`servers.${server.id}.badwordsystem.badwordlist`, wordlist);\n\tconst logchannel = bot.channels.get(String(db.get(`servers.${server.id}.badwordsystem.logchannelID`))) || false;\n\tvar usertype = db.get(`servers.${server.id}.badwordsystem.usertype`) || '@mention'; // @mention or usertag display on msg deletion log.\n\t(usertype === '@mention') ? usertype = (member || `an unknown user (${msg.author.id})`) : usertype = (member.user.tag || `an unknown user (${msg.author.id})`)\n\tconst wordtype = db.get(`servers.${server.id}.badwordsystem.wordtype`) || 'matchword'; // Choices are 'matchany', 'matchanycasing', 'wordmatch', 'wordmatchanycasing'.    Here are the differences explained:\n\t/* Original string user type:\"Oh Hello Bob, I am going to the store today.\"            And here is the bad word: 'hell'\n\t'matchany'\t\t\t\t\tDoes match. Exact 'hell' found in string (doesn't count casing). Also, doesn't matter that o is after hell.\n\t'matchanycasingmatters'\t\tDoes not match. Exact 'hell' not found in string (casing matters).\n\t'matchword'\t\t\t\t\tDoes not match. 'hell' word is not found b/c it's part of a larger word 'hello' (regardless of casing).\n\t'matchwordcasingmatters'\tDoes not match. 'hell' word is not found b/c it's part of a larger word 'hello'.\n\t\n\tAGAIN:\n\tOriginal string user type:\"Oh Hell Bob, that sucks for you, considering you're inhell\"            And here is the bad word: 'hell'\n\t'matchany'\t\t\t\t\tDoes match. Exact 'hell' found in string (doesn't count casing).\n\t'matchanycasingmatters'\t\tDoes match. Exact 'hell' found in string.\n\t'matchword'\t\t\t\t\tDoes match. 'hell' is found (regardless of casing).\n\t'matchwordcasingmatters'\tDoes not match. 'hell' word is not found (casing matters).\n\t*/\n\t\n\t// Not implemented yet:\n\tconst matchtype = db.get(`servers.${server.id}.badwordsystem.matchtype`) || 'standard'; // Following are the options (not fully implemented yet though):\n\t/*\n\t'strict' = A-Za-z0-9\t\t\t\t\t\t\t\tONLY these characters. Any other character causes the message to be deleted.\n\t'standard' = A-Za-z0-9\n\t'extended' = A-Za-zÀ-ÖØ-öø-ÿ0-9\t\t\t\t\t\tEssentially a user can't type fúck (accented u) and bypass the system.\n\t'maxium' = A-Za-zÀ-ÖØ-öø-ÿ0-9\\u00C0-\\u017F\t\t\tCovers \n\t*/\n\tconst regexflag = db.get(`servers.${server.id}.badwordsystem.regexflag`) || ''; // '', 'i', or 'u'. plan to add 'g' later on to support showing all bad words user typed, and take action based on the highest offensive word.\n/*\n\t// const logchannel = Files && Files.data && Files.data.servers && Files.data.servers[String(server.id)] && Files.data.servers[String(server.id)]['bad_words_log_channel'] || null;\n\tvar bad = [\n\t\t{ word: \"bad word1\", action: \"delete\" },\n\t\t{ word: \"bad word2\", action: \"delete\" },\n\t\t{ word: \"bad word3\", action: \"kick\" },\n\t\t{ word: \"bad word4\", action: \"kick\" },\n\t\t{ word: \"bad word5\", action: \"ban\" },\n\t\t{ word: \"bad word one\", action: \"call\" }\n\t];\n\t//var bad = globalVars(\"bad_words_list\"); // This is in array format. Converted to object format done below. Default global list.\n\n\tvar new_words = [\n\t\t{ word: \"bad word one\", action: \"ban\" },\n\t\t{ word: \"bad word one\", action: \"delete\" },\n\t\t{ word: \"one\", action: \"delete\" },\n\t\t{ word: \"two\", action: \"delete\" },\n\t\t{ word: \"three\", action: \"kick\" },\n\t\t{ word: \"four\", action: \"call\" },\n\t\t{ word: \"five\", action: \"ban\" }\n\t];\n\n\t//var new_words = globalVars(\"new_bad_words\");\n*/\n\t\n\t\n\tfunction wordlistToFormat(list, format) { // (wordlist), (upper/lowercase or matchtype)\n\t\tswitch (format) {\n\t\t\tcase \"lowercase\":\n\t\t\t\tfor (step=0; step < Object.keys(list).length; step++) { // pass into this for matchany\n\t\t\t\t\tlist[step]['word'] = String(list[step]['word']).toLowerCase();\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t\tbreak;\n\t\t\tcase \"uppercase\":\n\t\t\t\tfor (step=0; step < Object.keys(list).length; step++) {\n\t\t\t\t\tlist[step]['word'] = String(list[step]['word']).toUpperCase();\n\t\t\t\t}\n\t\t\t\treturn list; // Included this as an option just in case.\n\t\t\t\tbreak;\n\t\t\tcase \"matchword\":\n\t\t\t\tfor (step=0; step < Object.keys(list).length; step++) {\n\t\t\t\t\tlist[step]['word'] = RegExp('\\b'+String(list[step]['word'])+'\\b', 'i');\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t\tbreak;\n\t\t\tcase \"matchwordcasingmatters\":\n\t\t\t\tfor (step=0; step < Object.keys(list).length; step++) {\n\t\t\t\t\tlist[step]['word'] = RegExp('\\b'+String(list[step]['word'])+'\\b', '');\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t\tbreak;\n\t\t\tcase \"raw\": // Utilized for proper character escaping sequences. (Future feature)\n\t\t\t\tfor (step=0; step < Object.keys(list).length; step++) {\n\t\t\t\t\tlist[step]['word'] = String.raw`${list[step]['word']}`\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvar inMessage = false;\n\tvar messagedeleted = false;\n\t\n\tconst inmes = (props, object) => props.reduce((exists, x) => (exists && exists[x]) ? exists[x] : null, object); // This relies on 'matchany' mode.\n\t\n\t\n\t// This will convert each word to a RegExp with word boundaries.\n\tif (wordtype=='matchword') { // Match words (hell vs hello) of any casing Example: (HeLL vs heLL) matches.\n\t\twordlist = wordlistToFormat(wordlist, \"lowercase\");\n\t\twordlist = wordlistToFormat(wordlist, wordtype);\n\t} else if (wordtype=='matchwordcasingmatters') { // Match words (hell vs hello), Example: (HeLL vs heLL) does NOT match.\n\t\twordlist = wordlistToFormat(wordlist, wordtype);\n\t} else if (wordtype=='matchany') { // match anything, regardless of casing. 'HelL' triggers in 'hello'.\n\t\twordlist = wordlistToFormat(wordlist, \"lowercase\");\n\t} // 'matchanycasingmatters' doesn't need an if case as it tries to match exactly what's already there in the word list. 'hell' and 'hello' will  trigger in 'hello'.\n\t\n\t\n\t\n\t// The two wordtype cases that match irrespective of casing.\n\t(wordtype == 'matchany' || wordtype == 'matchword') ? messagetext = String(messagetext).toLowerCase() : messagetext = String(messagetext);\n\tconst stepnum = Object.keys(wordlist).length;\n\tvar actionstep = \"\"; var badword = \"\"; \n\tfor (step = stepnum; step >= 0; step--) { \n\t\tif (messagetext.match(inmes([step, 'word'], wordlist))) { // bad word found. Also match allows strings as well as regex, so that's nice.\n\t\t\tinMessage = true;\n\t\t\tbadword = inmes([step, 'word'], wordlist); // Saves the bad word to a variable to be used later.\n\t\t\tactionstep = inmes([step, 'action'], wordlist) || 'delete'; // Which action to take.\n\t\t\tbreak; // So that it doesn't have to search anymore in the ENTIRE wordlist for a word/words if and/or when it finds something.\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tvar channel = msg.channel.name;\n\tvar logmsg = \"\"; // Stores msg text to send to log channel if available.\n\t\n\tif (inMessage) {\n\t\tswitch (actionstep) {\n\t\t\tcase \"delete\":\n\t\t\t\ttry { \n\t\t\t\t\tthemessage.delete(); messagedeleted = true;\n\t\t\t\t\tlogmsg = logmsg+`Deleted message containing **\\`${(String(badword).length > 1900) ? String(badword).substring(0, 1897) + '…' : String(badword)}\\`** by ${usertype}.\\n`;\n\t\t\t\t} catch { \n\t\t\t\t\tlogmsg = logmsg+`I don't have delete messages permission in ${channel.name}\\n`;\n\t\t\t\t}\n\t\t\t\tif (logchannel && logmsg) { logchannel.send(logmsg); }\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase \"kick\":\n\t\t\t\ttry { themessage.delete();  messagedeleted = true;} catch { logmsg = logmsg+`I don't have delete messages permission in ${channel.name}`; }\n\t\t\t\tif (server.members.get(member.id).kickable) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmsg.author.send(`You have been kicked from ${(String(server.name).length > 100) ? String(server.name).substring(0,100) + '…' : String(server.name)} for typing **\\`${(String(badword).length > 1800) ? String(badword).substring(0, 1797) + '…' : String(badword)}\\`** in your message.\\n`)\n\t\t\t\t\t\t\n\t\t\t\t\t\tserver.members.get(theUSER).kick();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tlogmsg = logmsg+`Couldn't send Kick DM message to ${usertype}.\\n`;\n\t\t\t\t\t\tserver.members.get(theUSER).kick();\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserver.members.get(theUSER).kick().catch(\n\t\t\t\t\t\t\tif (logchannel) { logchannel.send(`Couldn't kick ${member.displayName || \"Unknown user\"} from this server. Make sure I'm higher than them!`); }\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tlogmsg = logmsg+`Couldn't kick ${usertype} from this server. Make sure I'm higher than them!\\n`;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t} else {\n\t\t\t\t\tlogmsg = logmsg+`${(messagedeleted===true)?\"Deleted message containing\":\"Couldn't delete message containing\"} **\\`${(String(badword).length > 1800) ? String(badword).substring(0, 1797) + '…' : String(badword)}\\`**\\n\\nAlso, I can't kick ${usertype}. Make sure I'm higher than them!\\n`;\n\t\t\t\t}\n\t\t\t\tif (logchannel && logmsg) { logchannel.send(logmsg); }\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase \"ban\":\n\t\t\t\ttry { themessage.delete();  messagedeleted = true;} catch { logmsg = logmsg+`I don't have **\\`manage messages\\`** permission in ${channel.name}\\n`; }\n\t\t\t\tif (server.members.get(member.id).bannable) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmsg.author.send(`You have been banned from ${(String(server.name).length > 100) ? String(server.name).substring(0,100) + '...' : String(server.name)} for typing **\\`${(String(badword).length > 1800) ? String(badword).substring(0, 1797) + '…' : String(badword)}\\`** in your message.\\n`);\n\t\t\t\t\t\t\n\t\t\t\t\t\tmsg.guild.ban(theUSER);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tlogmsg = logmsg+`Couldn't send Ban DM message to ${usertype}.\\n`;\n\t\t\t\t\t\tmsg.guild.ban(theUSER);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogmsg = logmsg+`${(messagedeleted===true)?\"Deleted message containing\":\"Couldn't delete message containing\"} **\\`${(String(badword).length > 1900) ? String(badword).substring(0, 1897) + '…' : String(badword)}\\`**\\n\\nAlso, I can't ban ${usertype}, ${(member.id == server.owner.id) ? \"b/c they are the server owner.\" : \"Make sure I'm higher than them!\"}\\n`;\n\t\t\t\t}\n\t\t\t\tif (logchannel && logmsg) { logchannel.send(logmsg); }\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// In development feature.\n\t\t\t// case \"call\":\n\t\t\t\t// themessage.delete();\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tmsg.delete(msg);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
      "storage": "0",
      "varName": "",
      "name": "Run Script"
    }
  ],
  "comType": "3"
}
